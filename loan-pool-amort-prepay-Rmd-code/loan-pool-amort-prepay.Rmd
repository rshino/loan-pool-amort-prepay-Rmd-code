---
title: "Mortgage Loan & Pool Amortization & Prepay Mechanics"
author: "Rei Shinozuka rei@reishinozuka.com"
date: "2025-05-28"
params:
    run_heavy_simulation: TRUE
output:
 
  pdf_document: 
    number_sections: yes
    fig_caption: yes
    includes:
      in_header: no-float.tex
      keep_tex: yes
      header-includes: 
        - \usepackage{longtable}
  html_document: 
    number_sections: yes
    fig_caption: yes
---

```{r setup, include=FALSE}
# where possible, I tried to minimize dependencies and libraries
# for example, we use base R plotting rather than ggplot2
# if you need to bail somewhere, use knitr::knit_exit()

library(dplyr)
library(data.table)
library(kableExtra)
library(nortest)
knitr::opts_chunk$set(echo = FALSE,warning=FALSE,
                      fig.pos='H',fig.width=6,fig.height=2.85,dpi=300)
# global parameters are below
# as demonstration code, we use global parameters for repeated exemplars
sched.prin.col<-"paleturquoise3"
int.col<-"paleturquoise"
unsched.prin.col<-"seagreen3"
ebal.col<-"darkblue"
ebal2.col<-"red"
cpr01.col<-"lightskyblue1"
cpr03.col<-"lightskyblue3"
cpr06.col<-"deepskyblue3"
cpr12.col<-"deepskyblue4"
baseline.cpr.col<-"red"
cex.size<-0.75
# final note: as demonstration code, generally we seek a simple sequential flow of control
# We define functions on where they are truly generalized and are not afraid to duplicate 
# code to illustrate the effect of different loan counts, for example.
```

```{r mortgage.parameters}
# mortgage parameters used in the loan and pool examples
orig.term<-360
note.rate<-0.06     # e.g., 0.06 == 6% annual note rate, or 0.5% monthly rate (no compounding)
orig.bal<-100*1000
scalar.cpr<-0.06    # flat CPR, e.g., 0.06 == 6% conditional prepay rate which is an annual 
                    # compounded rate
cpr<-replicate(orig.term,scalar.cpr)
# parameter string equivalents to basic parameters
scalar.smm<-1-(1-scalar.cpr)^(1/12)
note.rate.str<-sprintf("%5.3f%%",note.rate*100)
monthly.rate.str<-sprintf("%6.4f%%",note.rate/12*100)
orig.bal.str<-prettyNum(orig.bal,big.mark=",", scientific=FALSE)

scalar.cpr.str<-sprintf("%5.2f%%",scalar.cpr*100)
scalar.smm.str<-sprintf("%5.2f%%",scalar.smm*100)
complement.smm.str<-sprintf("%5.2f%%",(1-scalar.smm)*100)
# used to illustrate single loan curtailments
mo.borrower.pay<-700
```

```{r pool.simulation.params}
loan.count<-250
small.loan.count<-100
big.loan.count<-1000
yuge.loan.count<-10*1000
```

```{r level.pay.calc_f}
# level.pay.calc() =======================================================================
# returns level (scheduled) payment given term to maturity and note.rate normalized to 
# orig balance == 1.0
# rate of 0.0 is a special case, each month pays 1/rem.term of balance
#
level.pay.calc<-function(rem.term,monthly.rate)
{
  if(monthly.rate==0.0) { # special case of rate==0.0
    monthly.payment<-1/rem.term
  }
  else {
    monthly.payment<-(monthly.rate*(1+monthly.rate)^rem.term)/((1+monthly.rate)^rem.term-1)
  }
  return(monthly.payment)
}# level.pay.calc()
```

```{r amort.loan.cf_f}
# amort.loan.cf(orig.term,note.rate,orig.bal,cpr=c(NA),mo.borrower.pay=NA) ===============
#
# amortize single loan incorporating prepayments
# orig.term = mortgage term in months
# note rate = borrower interest, e.g., 0.06 == 6% annual
# orig.bal = borrower original balance
# cpr = CPR vector of size 1:orig.term
#   CPR == 1 signifies paid-in-full
#   0 < CPR < 1 are curtailments
# mo.borrower.pay = borrower sets his own monthly level payment higher
#   than the scheduled payment, e.g., rounding to the next $100 or $1000. when 
#   mo.borrower.pay is passed in, then cpr is not used
# 
amort.loan.cf<-function(orig.term,note.rate,orig.bal,cpr=c(NA),mo.borrower.pay=NA)
{
  monthly.rate<-note.rate/12
  level.pay<-level.pay.calc(orig.term,monthly.rate)*orig.bal    # derive sched borrower pay
  if(!is.na(mo.borrower.pay) & mo.borrower.pay<level.pay){      # error-check borrower pay
    print(sprintf("ERROR $%s mo.borrower.pay < $%s level.pay, ignoring",        
          prettyNum(round(mo.borrower.pay,2),big.mark=",", scientific=FALSE),
          prettyNum(round(level.pay,2),big.mark=",", scientific=FALSE)
          ))
    mo.borrower.pay<-NA
  }
  
  if(is.na(cpr[1]) | !is.na(mo.borrower.pay)){                      
    smm<-replicate(orig.term,0)
  } else {
    smm<-1-(1-cpr)^(1/12)
  }
  # initialize data.table for output
  cf<-data.table(mon=1:orig.term)
  cf[,bbal:=0]
  cf[1,bbal:=orig.bal]
  cf[,int:=0]
  cf[,sched.prin:=0]
  cf[,unsched.prin:=0]
  cf[,prin:=0]
  cf[,eschedbal:=0]
  cf[,ebal:=0]
  # begin amortization
  mo.bbal<-orig.bal
  mo.unsched.prin<-0
  for(m in 1:orig.term){  # unfortunately we must use loop as each month depends on results
                          # from prior month (can't vectorize)
    mo.int<-mo.bbal * monthly.rate        # pay interest first
    mo.sched.prin<-min(mo.bbal,level.pay - mo.int)     # remainder of payment is sched prin
    mo.eschedbal<-mo.bbal - mo.sched.prin # balance after sched prin is sched bal
    if (!is.na(mo.borrower.pay)){
      mo.unsched.prin<-mo.borrower.pay - level.pay  # unsched prin is % of sched bal
    } else {
      mo.unsched.prin<-mo.eschedbal*smm[m]  # unsched prin is % of sched bal
    }
    mo.prin<-mo.sched.prin + mo.unsched.prin # total prin is sched + unsched prin
    mo.ebal<-mo.bbal - mo.prin            # ending actual balance
    # copy results to data.matrix as actual borrower cashflows, rounding to $0.01
    cf[m,bbal:=round(mo.bbal,2)]
    cf[m,int:=round(mo.int,2)]
    cf[m,sched.prin:=round(mo.sched.prin,2)]
    cf[m,unsched.prin:=round(mo.unsched.prin,2)]
    cf[m,prin:=round(mo.prin,2)]
    cf[m,eschedbal:=round(mo.eschedbal,2)]
    cf[m,ebal:=round(mo.ebal,2)]
    if(mo.ebal<=0.005) break
    mo.bbal<-mo.ebal                    # for next month
  }
  return (cf)
}# amort.loan.cf()
``` 

```{r amort.pool.cf_f}
# amort.pool.cf() ========================================================================
#
# Amortize loan pool using MBS convention which models the pool balance and prepayments as 
# continuous. The pool would theoretically consisting of many loans of 0.01 each
# CPR in a given month represents the % of loans that PAY IN FULL that month
# there is no provision for curtailments
#
amort.pool.cf<-function(orig.term,note.rate,orig.bal,cpr=c(NA))
{
  monthly.rate<-note.rate/12
  if(is.na(cpr[1])){
    smm<-replicate(orig.term,0)
  } else {
    smm<-1-(1-cpr)^(1/12)
  }
  # initialize data.table for output
  cf<-data.table(mon=1:orig.term)
  cf[1,bbal:=orig.bal]
  cf[,int:=0]
  cf[,sched.prin:=0]
  cf[,unsched.prin:=0]
  cf[,prin:=0]
  cf[,eschedbal:=0]
  cf[,ebal:=0]
  mo.bbal<-orig.bal
  mo.unsched.prin<-0
  for(m in 1:orig.term){ # must loop as each month depends on prior month
    level.pay<-level.pay.calc(orig.term+1-m,monthly.rate)*mo.bbal  # recalc level pay based 
                                            # on act bal, implying SMM paid in full
    mo.int<-mo.bbal * monthly.rate          # pay interest first
    mo.sched.prin<-level.pay - mo.int       # remainder is sched prin
    mo.eschedbal<-mo.bbal - mo.sched.prin   # bal after sched prin is sched bal
    mo.unsched.prin<-mo.eschedbal*smm[m]    # unsched prin is % of sched bal
    mo.prin<-mo.sched.prin + mo.unsched.prin # total prin = sched + unsched prin
    mo.ebal<-mo.bbal - mo.prin              # actual bal
    # copy results to data.matrix as remitted pool cashflows, rounding to $0.01
    cf[m,bbal:=round(mo.bbal,2)]
    cf[m,int:=round(mo.int,2)]
    cf[m,sched.prin:=round(mo.sched.prin,2)]
    cf[m,unsched.prin:=round(mo.unsched.prin,2)]
    cf[m,prin:=round(mo.prin,2)]
    cf[m,eschedbal:=round(mo.eschedbal,2)]
    cf[m,ebal:=round(mo.ebal,2)]
    if(mo.ebal<0.005) break               # half-cent tolerance
    mo.bbal<-mo.ebal # for next month
  }
  return (cf)
} # amort.pool.cf
``` 


```{r scale.axis.max}
# scal.axis.max(val,divisions) ===========================================================
# 
# convenience function to find aesthetic max, where significant is divisible by 4
scale.axis.max<-function(val,divisions=4){
  power.floor<-floor(log(val,10))
  power.ceil<-ceiling(log(val,10))
  if (val/10^power.ceil > 0.7){
    return (10^power.ceil)
  }
  return (ceiling(val/10^power.floor/divisions)*divisions*10^power.floor)
} # scale.axis.max()
```

```{r plot.cfs.f}
# plot.cfs(cf,title) ===================================================================== 
#
# plot cashflows
#
plot.cfs<-function(cf,title){
  par(mar=c(bottom=5, left=5, top=3, right=5) + 0.1) # bot, left, top, right in lines
  maxy<-scale.axis.max(max(cf$int+cf$sched.prin+cf$unsched.prin))
  displ.y<-maxy
  suff.y<-"($)"
  if(maxy>1000*1000){
    displ.y<-maxy/1000
    suff.y<-"($1,000s)"
  }
  cfm<-as.matrix(cf[,c("int","sched.prin","unsched.prin")])
  rownames(cfm)<-cf$mon
  cfmt<-t(cfm) # transpose
  barplot(cfmt,border=NA,col=c(int.col,sched.prin.col,unsched.prin.col),space=c(0,0),
          ylim=c(0,maxy),
          cex.main=cex.size, 
          xaxt="n",yaxt="n",xlab="",ylab="",main=title)
  axis(1, at = seq(0, orig.term, 12*5),cex.axis=cex.size)
  axis(2, at = seq(0, maxy, maxy/4),
       prettyNum(seq(0, displ.y, displ.y/4),big.mark=",", 
                 scientific=FALSE),las=1,cex.axis=cex.size)
  maxy2<-max(cf[!is.na(cf$bbal)]$bbal)

  displ.y2<-maxy2
  suff.y2<-"($)"
  if(maxy2>1000*1000){
    displ.y2<-maxy2/1000
    suff.y2<-"($1,000s)"
  }
  
  par(new=TRUE)     # new plot on same canvas, for ending balance
  plot(cf$mon,cf$ebal,type="l",col=ebal.col,xlab="", lty=2, ylab="",xaxt="n",yaxt="n",
       axes=FALSE,cex.main=cex.size ## cex.axis=cex.size,cex.lab=cex.size
  )
  axis(4, at = seq(0, maxy2, maxy2/4),
     prettyNum(seq(0, displ.y2, displ.y2/4),big.mark=",", scientific=FALSE),las=1,
     cex.axis=cex.size)
  
  mtext("Age (Mo.)",side=1,line=2.0,cex=cex.size) 
  mtext(paste("Monthly Cashflow",suff.y),side=2,line=4.0,cex=cex.size) 
  mtext(paste("Ending Bal.",suff.y2),side=4,line=4.0,cex=cex.size) 
  legend(x="bottom", xpd=TRUE,inset = c(0, -0.75),horiz=TRUE,cex=cex.size,
         legend=c("Interest","Sched.Prin.","Unsched.Prin.","Ending Balance"),
         lty=c(1,1,1,2),
         col=c(NA,NA,NA,ebal.col),
         fill=c(int.col,sched.prin.col,unsched.prin.col,NA),border=NA,
         bty="n"
         )
  cat('\n\n')
} # plot.cfs()
```

```{r plot.comp.bals.f}
plot.comp.bals<-function(cf,cf2,title){
  par(mar=c(bottom=5, left=5, top=3, right=5) + 0.1) # bot, left, top, right in lines
  
  maxy2<-max(cf[!is.na(cf$bbal)]$bbal)

  maxy<-max(cf[!is.na(cf$bbal)]$bbal,cf2[!is.na(cf2$bbal)]$bbal)
  displ.y<-maxy
  suff.y<-"($)"
  if(maxy>1000*1000){
    displ.y<-maxy/1000
    suff.y<-"($1,000s)"
  }

  plot(cf$mon,cf$ebal,type="l",col=ebal.col,main=title,
       xlab="", ylab="",xaxt="n",yaxt="n",axes=FALSE,
       cex.main=cex.size) 
  lines(cf2$mon,cf2$ebal,lty=2,col=ebal2.col) # dashed
  axis(1, at = seq(0, orig.term, 12*5),cex.axis=cex.size)
  axis(2, at = seq(0, maxy, maxy/4),
       prettyNum(seq(0, displ.y, displ.y/4),big.mark=",", scientific=FALSE),
       las=1,cex.axis=cex.size)

  mtext("Age (Mo.)",side=1,line=2.0,cex=cex.size) 
  mtext(paste("Ending Bal.",suff.y),side=2,line=4.0,cex=cex.size) 
  legend(x="bottom", xpd=TRUE,inset = c(0, -0.75),horiz=TRUE,cex=cex.size,
         legend=c("Loan Simulation","MBS Convention"),
         lty=c(1,2),
         col=c(ebal.col,ebal2.col),
         bty="n"
         )
  cat('\n\n')
} # plot.comp.bals()
```

# Amortization and Prepayment Mechanics for Fixed-Rate Level-Pay Mortgages

## Scope and Definitions

Fixed-Rate Level-Pay mortgages comprise the great majority of loans originated in the US.

* Fixed-Rate: constant interest rate over the life of the loan

* Level-Pay: Loan is structured such that monthly payment is constant over the life of the loan.

The level-pay structure is facilitated by *amortizing* the balance over the life of the loan after paying monthly interest. The amount of the amortization is known as the *scheduled principal* and the remaining balance is known as the *scheduled balance*.

Most of the numerical conventions which follow are based on the reference
*Standard Formulas for the Analysis of Mortgage-Backed Securities and Other Related Securities*
(1999) published by the **Bond Market Association** (today known as **SIFMA**) 
available at the URL:

https://www.sifma.org/wp-content/uploads/2017/08/chsf.pdf

and denoted *SF1999* in any references below.

Other resources on mortgage amortization:

https://hughcalc.org/formula.php

https://hughcalc.org/formula_deriv.php

The equation notation used in this document will not exactly correspond to the 
sources but is generally consistent with the sources.
^[In the equation exhibits, a 6% note rate would generally be represented as 0.06 or as a monthly rate of 0.005, a 12% CPR would be 0.12, etc.
This avoids the proliferation of the constants 100 and 1200 found in the source material.
The R code follows this convention.
]

## Basic Loan Amortization Mechanics

### Loan Amortization 

The below example shows scheduled amortization, which occurs when the borrower pays exactly the monthly payment
each month. Principal and interest equal the monthly payment, which may be referred to as the *scheduled payment* 
with interest comprising the majority of the monthly payment in the early part of the loan. Under scheduled 
amortization, the balances at the end of each month are referred to as *scheduled balance*, the principal amount of
the scheduled payment each month is referred to as the *scheduled principal*.
The payment window is the term of the loan.

Each month the borrower remits the scheduled monthly payment *m*, comprising of interest *i~i~* and principal *p~i~*, the reduction of principal resulting in a monthly
ending balance *B~i~*.

$$
\begin{aligned}
m & = i_i + p_i \\
i_i & =B_{i-1} r_m\\
p_i & =m-B_{i-1} r_m\\
B_i & =B_{i-1}-p_1\\
   & =B_{i-1}-(m-B_0 r_m)\\
   & =B_{i-1}+B_{i-1} r_m-m\\
   & =B_{i-1}(1+r_m)-m
\end{aligned}
$$
The monthly payment is calculated from note rate, balance, and loan term. 
*r~m~* is the monthly interest rate, or $\frac{note rate}{12}$, *B~0~* is 
the original loan balance and *T* is term of the loan in months.


$$
\begin{aligned}
m = 
\begin{cases}
B_0 \frac{r_m}{1-(1+r_m)^{-T}}  & ,r_m \ne 0 \\
\frac{B_0}{T} & ,r_m = 0
\end{cases}
\end{aligned}
$$
Derivation is in the appendix.



```{r amortization}
#| fig.cap='Scheduled Amortization'
cpr.eg<-0
cprsingle<-replicate(orig.term,cpr.eg)
cfloan<-amort.loan.cf(orig.term,note.rate,orig.bal,cprsingle)
title<-sprintf("%3.3f%% Loan Scheduled Amortization (%3.1f%% CPR)",note.rate*100,cpr.eg*100)
plot.cfs(cfloan,title)
#knitr::knit_exit()
# m & =`r orig.bal.str` \frac{`r monthly.rate.str`}{1-(1+`r monthly.note.str`)^{-360}} 

```

For our example loan, the
monthly payment is:

$$
\begin{aligned}
m & =B_0 \frac{r_m}{1-(1+r_m)^{-360}} \\
 & =`r orig.bal.str` \frac{`r note.rate/12`}{1-(1+`r note.rate/12`)^{-360}} \\
 & =`r round(orig.bal*(note.rate/12)/(1-(1+note.rate/12)^(-360)),2)` 
\end{aligned}
$$
The first month principal, interest and remaining balance is:


$$
\begin{aligned}
r_m & = `r note.rate/12` \\
B_0 & =`r orig.bal.str` \\
i_1 & =`r orig.bal*note.rate/12` \\
p_1 & =`r round(orig.bal*(note.rate/12)/(1-(1+note.rate/12)^(-360))-orig.bal*note.rate/12,2)` \\
B_1 & =`r prettyNum(
  round(
    orig.bal-(orig.bal*(note.rate/12)/(1-(1+note.rate/12)^(-360))-orig.bal*note.rate/12),2
    ),big.mark=",")`
\end{aligned}
$$



### Early Loan Repayment

The borrower has the right to pay off the full balance of the loan at any time, to facilitate a 
refinancing or property sale,
resulting in the loan being *paid in full*. 

The below example shows a loan paying in full prior to loan maturity. 

```{r payment.in.full}
#| fig.cap='Borrower Repayment prior to Term'
pif.mon<-354
cprsingle<-replicate(orig.term,0)
cprsingle[pif.mon]<-1.0
cfloan<-amort.loan.cf(orig.term,note.rate,orig.bal,cprsingle)
title<-sprintf("%3.3f%% Loan Payment in Full at month %3d",note.rate*100, pif.mon)
plot.cfs(cfloan,title)
```


### Loan Curtailments

The borrower may also partially prepay the remaining balance
of the loan resulting in a *curtailment*.  
Curtailments are typically small relative to the monthly payment, often produced when 
borrowers round up the monthly payment to a multiple of $100
to simplify book keeping or to shorten the loan term.  
Both payments-in-full and curtailments are types of *prepayments*,
also known as *unscheduled principal* payments.

We extend the cash flow model to accommodate prepayments.
The borrower has the same scheduled monthly payment *m*, comprising of interest *i~i~* and principal *p~S,i~*. The *S* in the subscript denotes *scheduled* principal.
The borrower may also remit additional principal up to the loan remaining balance, which 
we denote *p~U,i~* for *unscheduled* principal. 
We differentiate *scheduled* balance *B~U,i~* as the ending balance after amortizing with scheduled principal *p~S,i~* and *actual* balance *B~A,i~* as the ending balance after scheduled and unscheduled principal.

$$
\begin{aligned}
m & = i_i + p_{U,i} \\
i_i & =B_{A,i-1} r_m\\
p_{S,i} & =m-B_{A,i-1} r_m\\
B_{S,i} & =B_{A.i-1}-p_{S,i}\\
   & =B_{A.i-1}-(m-B_0 r_m)\\
   & =B_{A,i-1}+B_{A,i-1} r_m-m\\
   & =B_{A,i-1}(1+r_m)-m\\
B_{A,i} & =B_{A.i-1}-p_{S,i}-p_{U,i}\\
\end{aligned}
$$
Curtailments do not change the scheduled payment (interest plus scheduled principal). 
The curtailments accelerate the paydown of remaining loan balance and hence reduce the duration of the payment window.
The total interest paid is also reduced.

The below example shows a loan where the borrower pays a higher monthly amount 
$`r prettyNum(round(mo.borrower.pay,2),  big.mark=",", scientific=FALSE)`
than the scheduled amount. 
$`r prettyNum(round(level.pay.calc(orig.term,note.rate/12)*orig.bal,2),  big.mark=",", scientific=FALSE)`.
The excess amount
$`r prettyNum(round(mo.borrower.pay-level.pay.calc(orig.term,note.rate/12)*orig.bal,2),  big.mark=",", scientific=FALSE)`
is the monthly curtailment, which reduces the remaining balance and brings the final payment to an earlier date
(in this example nearly 10 years.)
This is the more typical manner in which curtailments occur.

```{r level.curtailment}
#| fig.cap='Borrower Rounding-Up Payment (Curtailment)'
cfloan<-amort.loan.cf(orig.term,note.rate,orig.bal,cpr=c(NA),mo.borrower.pay=mo.borrower.pay)
title<-sprintf("%3.3f%% Loan Curtailments ($%s monthly payments)",note.rate*100,
               prettyNum(round(mo.borrower.pay,2),big.mark=",", scientific=FALSE))
plot.cfs(cfloan,title)
```

The below example shows a loan which curtails monthly as a percent of the scheduled remaining balance.
This rate annualized is known as *conditional prepayment rate (CPR)*.
It is based on the *Single Monthly Mortality (SMM)* which captures prepayments as a
proportion to the ending scheduled balance for a given month. Conversely, a 
model might estimate a loan or pool's incentive to prepay and express this as an SMM
from which unscheduled principal is calculated.

$$
\begin{aligned}
SMM_i &= \frac{p_{U,i}}{B_{S,i}}\\
p_{U,i} &= B_{S,i} SMM_i \\
\end{aligned}
$$
As mentioned earlier CPR is the annualized measure of SMM:

$$
\begin{aligned}
CPR &= 1-(1-SMM)^{12} \\
SMM &= 1-\sqrt[12]{1-CPR}
\end{aligned}
$$

$$
\begin{aligned}
B_{A,i} & =B_{A.i-1}-p_{S,i}-p_{U,i}\\
 & =B_{S.i}- B_{S,i} SMM_i\\
   & =B_{S.i}(1-SMM_i)
\end{aligned}
$$


In contrast to the rounded-up monthly example above, in this example the rate of curtailment as a percentage
of scheduled remaining balance is constant, but the *amount* of curtailments here decrease over time
with balance. 

```{r curtailment}
#| fig.cap='Borrower Curtailment as Percentage of Remaining Balance'
cpr.eg<-0.01
cprsingle<-replicate(orig.term,cpr.eg)
cfloan<-amort.loan.cf(orig.term,note.rate,orig.bal,cprsingle)
title<-sprintf("%3.3f%% Loan Curtailments (at %3.1f%% CPR)",note.rate*100,cpr.eg*100)
plot.cfs(cfloan,title)
```

## Loan Cashflows versus Pool Cashflows

The growth of Mortgage-Based Securities (MBS) in the 1980s led investors to evaluate mortgage loans as bonds collateralized by
pools of loans. The borrower's option to refinance the loan is to the investor a short call option. Reflecting this exposure, MBS investor reporting attempts to describe historical prepayments and investor analysis
requires assumptions to project future prepayments. 

*SF1999* describes the basic measure of pool prepayments is *single monthly mortality (SMM)* which is the monthly ratio of aggregate unscheduled principal payments to the pool's scheduled ending balance. More commonly,
prepayments are specified as a *conditional prepayment rate (CPR)* which is the compounded annualized SMM.

When SMM and CPRs are inferred from loan and pool cashflows, these are *historical prepayments.*
When projecting future cashflows of a pool from a point in time to full paydown, SMMs and CPRs are
*projected prepayments*. When a quantitative model is used to determine the borrower incentive to prepay from rates and other macroeconomic factors, the SMMs and CPRs are referred to as *model (projected) prepayments*.

Projected prepayments almost always utilize the *MBS convention.*
The CPR assumption used to project pool cashflows abstracts the mortgage pool into a homogeneous asset 
which any proportion of remaining balance may be prepaid. This abstraction does not recognize individual loans within the pool. Rather, it assumes the pools 
are infinitely divisible, or more practically
consist of a very large number of infinitesimally sized loans. 
Actual behavior is that individual borrowers decide on a monthly basis to prepay their loans based on a rate incentive utility function, or exogenous events leading to housing turnover.
The convention adopted by MBS investors is that pool prepayments are continuous 
functions which can approximate the discrete loan behavior of actual loan pools. 
The difference between the continuous and discrete view is minimized when pools consist of the large number of loans (>500 loan count) typically required for MBS securitization.

To illustrate these distinctions, this section contrasts:

  * Loan Amortization and Prepayment
  
  * MBS Convention for Pool Amortization and Prepayment
  
  * Loan Simulation for Pool Amortization and Prepayment

### Parameters used in Examples

  * Original Term = `r orig.term`
  
  * Note rate = `r note.rate.str`
  
  * Original Loan Balance = `r orig.bal.str`
  
  * Monthly payment = `r prettyNum(round(level.pay.calc(orig.term,note.rate/12)*orig.bal,2),
    big.mark=",", scientific=FALSE)`
  
  * Conditional Prepayment Rate (CPR) = `r scalar.cpr.str`
  
  * Pool Loan Count = `r loan.count`

### Loan Amortization and Prepayment

The single loan is modeled following its contractual terms.

CPRs for single loans are treated as: 

  1. Scheduled amortization (CPR == 0%)
  
  2. Curtailments (0% < CPR < 100%) or 
  
  3. Payments in full (CPR == 100%)

Other characteristics of single loan amortization:

  1. the Scheduled Payment does not change
  
  2. Coupon does not change over time
  
  3. Age and Remaining Term increment by 1 and -1 respectively every month
  
  4. Nonzero CPR < 100% represents curtailments, which 

      a. reduce the payment window by accelerating the final paydown to zero
      
      b. do not affect scheduled (level) payment

```{r amort.loan}
#| fig.cap='Loan Paydown'

cfloan<-amort.loan.cf(orig.term,note.rate,orig.bal,cpr)
title<-sprintf("Single %3.3f%% Loan Cashflow %3.1f%% CPR Curtailments",
               note.rate*100,scalar.cpr*100)
plot.cfs(cfloan,title)
```


### MBS Convention for Pool Amortization and Prepayment


The MBS convention assumes prepayments are *continuous*, 
implying pools consist of infinite number of loans each of *infinitesimal size*. 
There is no modeling of loans and loan counts 
^[Loan count may be inferred if average loan size is an attribute of the pool, however any such inferred loan count would be ignored in processing prepayments.]
Balances and other metrics represent the aggregated values 
of loans constituting the original pool. 

*SF1999* explicitly describes a pool factor $\frac{current face}{original face}$ as:

$$
\begin{aligned}
\operatorname{POOL FACTOR} &= \operatorname{SURVIVAL\ \ FACTOR} 
\times
\operatorname{AMORTIZED\ \ LOAN\ \ BALANCE}
\end{aligned}
$$
which compartmentalizes prepayments and amortization. The pool amortizes as 
a very large loan and prepayments, and prepayments reduce the survival factor
directly.

CPRs under MBS pool convention is treated as: 

1. paid in full for a proportion of loans up to 100% (CPR > 0%) 

2. scheduled amortization (CPR == 0%)

3. There is no accommodation for curtailment 
^[The MBS Convention interprets pool prepayments as full loan repayments, not partial repayments. The timing of cashflows cannot change.]

#### Example: 

1. Assume flat `r scalar.cpr.str` CPR

2. `r scalar.cpr.str` CPR is annualized equivalent of `r scalar.smm.str` Single Monthly Mortality (SMM).

3. Each month, `r scalar.smm.str` of the loans are assumuled to pay in full, reducing actual balances by that amount

4. The scheduled level payment is also reduced by `r scalar.smm.str` reflecting the paydowns.

#### MBS Convention pool paydown characteristics:

1. the pool scheduled monthly payment is reduced after every prepayment

2. the coupon and pool aggregate measures are invariant over time and prepayments

3. age and remaining term increment by exactly 1 and -1 respectively every month

    a. age represents Weighted Average Loan Age (WALA)
    
    b. remaining term represents Weighted Average Maturity (WAM)
  
4. Pools extend to their stated maturity; prepayments do not affect the payment window
  
  
```{r amort.pool}
#| fig.cap='Pool Paydown using MBS Convention'

pool.orig.bal<-orig.bal*loan.count
cfpool<-amort.pool.cf(orig.term,note.rate,pool.orig.bal,cpr)

title<-sprintf("MBS Convention %3.3f%% Pool Cashflows, %3.1f%% CPR",
               note.rate*100,scalar.cpr*100)
plot.cfs(cfpool,title)

```

### Loan Simulation for Pool Amortization and Prepayment

Loan simulation models a pool as the aggregate of a *specific number* of 
loans of *specific size*. 
^[Though not captured in this 
simulation example, loans may possess heterogeneous properties (different coupons, sizes, etc.) would would permit characteristics of the pool to change over time and prepayments, e.g., WAC drift)].

The simulation interprets an SMM as the probability for an individual loan being paid in full each month. In this implementation there is no provision made for curtailment.
^[Individual loans could in fact curtail in simulation, if a curtailment function were defined, distinct and separate from the prepayment function. ]

#### Example: 

1. The pool consists of `r loan.count` loans each of size `r orig.bal.str`.

2. Assume flat `r scalar.cpr.str` CPR

3. `r scalar.cpr.str` CPR is annualized equivalent of `r scalar.smm.str` Single Monthly Mortality (SMM).

4. Each month, each loan has a `r scalar.smm.str` probability of paying in full and `r complement.smm.str` probability of amortizing.

5. The scheduled level payment is reduced by the scheduled level payments of those loans paying in full.

```{r simulate.loan.pool_f}
# simulate.loan.pool(orig.term,note.rate,orig.bal,scalar.cpr,loan.count) ----------------
#
# NOTE: This is a "slow" version of simulate.loan.pool() see NOTE below
# convert prepayments to probabilities, CPR is probability a loan will prepay in full in 
# the year, SMM the probabilty a loan will prepay in the month. For each loan, randomly 
# simulate a projected time series of binary payment outcomes, 1.0 for paid in full 
# and 0.0 for amortize. This series translates directly to CPR (or SMM, as the 0.0 and 1.0 
# are equivalent CPR and SMM) vectors which are passed into the amort.loan.cf() function. 
# Each loan cashflow is aggregated into a pool cashflow. The resulting pool cashflow of 
# discrete loan prepayments more closely resembles observable pool cashflows than the 
# continuous cashflows using the MBS pool convention, but converges with theMBS pool 
# convention as loan count exceeds 250 or more.  This simulation offers is no provision for
# curtailment.
#
# NOTE: This is a "slow" version of simulate.loan.pool() which 
# amortizes every loan brute-force, which can theoretically accommodate loans with unique
# characteristics
#
simulate.loan.pool<-function(orig.term,note.rate,orig.bal,scalar.cpr,loan.count){
  cpr<-replicate(orig.term,scalar.cpr)
  smm<-1-(1-cpr)^(1/12)
  #schedcf<-amort.loan.cf(orig.term,note.rate,orig.bal,cpr=c(NA)) # sched
  for(loan.no in 1:loan.count){
    pifcpr<-runif(n=orig.term)  # uniformly random for each month 1:orig.term
    pifcpr<-(pifcpr<smm)*1      # interpret smm as a probability of monthly PIF
    cf1<-amort.loan.cf(orig.term,note.rate,orig.bal,pifcpr)
    
    # accumulate individual loan cashflows to the pool level
    if(loan.no==1){
      cfsim<-cf1
    } else {
      cfsim<-cfsim+cf1
    }
  }
  cfsim$mon<-cfsim$mon/loan.count
  return(cfsim)
}# simulate.loan.pool()
```

```{r simulate.loan.pool.f_f}
# simulate.loan.pool.f(orig.term,note.rate,orig.bal,scalar.cpr,loan.count) ===============
#
# NOTE: This is a "fast cheater" version of simulate.loan.pool.f() see NOTE below
# convert prepayments to probabilities, CPR is probability a loan will prepay in full in the 
# year, SMM the probabilty a loan will prepay in the month. For each loan, randomly simulate
# a projected time series of binary payment outcomes, 1.0 for paid in full and 0.0 for 
# amortize. This series translates directly to CPR (or SMM, as the 0.0 and 1.0 are equivalent 
# CPR and SMM) vectors whichare passed into the amort.loan.cf() function. Each loan cashflow 
# is aggregated into a pool cashflow. 
# The resulting pool cashflow of discrete loan prepayments more closely resembles observable 
# pool cashflows than the continuous cashflows using the MBS pool convention, but converges 
# with the MBS pool convention as loan count exceeds 250 or more.
# This simulation offers is no provision for curtailment.
#
# NOTE: This is a "fast cheater" version of simulate.loan.pool.f() which assumes every loan
#       is identical (term,note rate,orig.face). At this time (May 2025) the "fast" version
#       return the same output as the "slow" version, but about 50 times faster.
# The fast cheater:
#   amortizes loan only once per call (to data.table schedcf)
#   for each loan generates random binary smm vector simulating scalar.cpr
#   derives PFI month (idx) from smm vec
#   deep-copies schedcf to cf1
#   and manually sets unsched.prin to ebal at month idx
#   zeroes out following months of cf1
#   accumulates pool cfs same as in the slow version
#
simulate.loan.pool.f<-function(orig.term,note.rate,orig.bal,scalar.cpr,loan.count){
  cpr<-replicate(orig.term,scalar.cpr)
  smm<-1-(1-cpr)^(1/12)
  schedcf<-amort.loan.cf(orig.term,note.rate,orig.bal,cpr=c(NA)) # scheduled cashflows ONCE
  for(loan.no in 1:loan.count){
    pifcpr<-runif(n=orig.term)  # uniformly random for each month 1:orig.term
    pifcpr<-(pifcpr<smm)*1      # interpret smm as a probability loan will PFI this month
    idx<-match(1.0,pifcpr) # PIF month (only first occurrence)
    if(!is.na(idx)&idx<orig.term){ # idx not NA and not last CF
      cf1<-copy(schedcf) # make a deep copy
      cf1[idx,unsched.prin:=ebal] # PIF
      cf1[idx,ebal:=0.0]          # PIF
      # zero out following CF attributes in subsequent periods to term
      cf1[(idx+1):orig.term,c("bbal","int","sched.prin","unsched.prin",
                              "prin","eschedbal","ebal"):=0.0]        
    } else {
      cf1<-schedcf # if no prepay then use sched bal; no need to deep copy
    }
    # accumulate individual loan cashflows to the pool level
    if(loan.no==1){
      cfsim<-cf1
    } else {
      cfsim<-cfsim+cf1
    }
  }
  cfsim$mon<-cfsim$mon/loan.count
  return(cfsim)
}# simulate.loan.pool()
```

```{r print.time.stats_f}
# print.time.stats() =====================================================================
# helper function to pretty print proc_time object from system.time() call 
print.time.stats<-function(time,title=NA){
  cat("\n\n")
  #knitr::kable(t(time[1:3]),
   kbl(t(time[1:3]),
              caption=title, booktabs=T,longtable=T,
               col.names=c("User Time (sec)","System Time (ec)","Elapsed Time (sec)"),
               format.args=list(width=20)) %>% ## kable_styling()
            kable_paper("striped", full_width = F) # kable_styling()
}# print.time.stats()
```

```{r pool.simulation}
#| fig.cap='{Pool Paydown by Simulation'

set.seed(666) # replicable in isolation
time<-system.time(
  cfsim<-simulate.loan.pool.f(orig.term,note.rate,orig.bal,scalar.cpr,loan.count)
  )
title<-sprintf("%d Loan Pool Simulation",loan.count)
print.time.stats(time,title=title)
```


```{r pool.simulation.results}
#| fig.cap='Pool Paydown by Loan Simulation'
title<-sprintf("%3.3f%% Pool Loan Simulation Cashflows, %d Loans, %3.1f%% CPR",
                note.rate*100,loan.count,scalar.cpr*100)
plot.cfs(cfsim,title)
```

#### Comparing Loan Simulation against MBS Convention

With higher loan counts, loan simulation approaches results of the MBS convention.


```{r pool.simulation.comparison}
#| fig.cap='Comparing Loan Simulation vs. MBS Convention'
title<-sprintf("%3.3f%% Loan Simulation vs MBS Convention, %d Loans %3.1f%% CPR",
               note.rate*100, loan.count,scalar.cpr*100)
plot.comp.bals(cfsim,cfpool,title)

```



```{r calc.hist.cpr.f}
# calc.hist.cpr(cf) ======================================================================
#
# given a pool (or loan) cashflow calculate 1-,3-,6- and 12-month CPR
# cashflow cf is a data.table minimally containg the following 4 attributes for each month
#
# mon   bbal      ebal      unsched.prin
# 1     5000000.0 4960467.5  25643.63
# 2     4960467.5 4921209.3  25440.68
# ...
# mon          = timeseries month (index):   cf[1,] represents the first cashflow
# bbal         = beginning (actual) balance: cf[1,bbal] the original balance of loan or pool
# ebal         = ending (actual) balance:    cf[1,ebal] the remaining bal after 1st payment
# unsched.prin = unscheduled principal:      cf[1,unsched.prin] borrower payment excess of 
#                                             sched pay incorporates payments of full 
#                                             repayments and curtailments
# implementation note: data.table() allows this to be vectorized nicely
#
calc.hist.cpr<-function(cf){
  orig.term<-nrow(cf)
  last.cf<-sum(cf$bbal>0)

  hist.cpr<-data.table(mon=1:orig.term)
  hist.cpr$bbal<-cf$bbal
  hist.cpr$ebal<-cf$ebal
  hist.cpr$sched.prin<-cf$sched.prin
  hist.cpr$unsched.prin<-cf$unsched.prin
  # hist.cpr[,wam:=orig.term-mon]
  # collect trailing 1,3,6,12-month unscheduled principal
  # this is the only section requiring shift(1..11)
  hist.cpr[(bbal>0),uprin01:=unsched.prin]  
  hist.cpr[(bbal>0)&(mon<last.cf-2),
           uprin03:=uprin01+shift(unsched.prin,1)+shift(unsched.prin,2)]
  hist.cpr[(bbal>0)&(mon<last.cf-5),
           uprin06:=uprin03+shift(unsched.prin,3)+shift(unsched.prin,4)+
             shift(unsched.prin,5)]
  hist.cpr[(bbal>0)&(mon<last.cf-11),
           uprin12:=uprin06+shift(unsched.prin,6)+shift(unsched.prin,7)+
             shift(unsched.prin,8)+shift(unsched.prin,9)+
             shift(unsched.prin,10)+shift(unsched.prin,11)]
  # determine 1-,3-,6-,12-mo scheduled ending balances for month m
  # e.g., hist.cpr[m,sched.ebal01] is the sched bal projected from hist.cpr[m-1,ebal] 
  #       sched.ebal01 for month m is m's ending balance plus m's unsched prin
  #       sched.ebal03 for month m is m's ending balance plus unsched prin in month m, 
  #                                       m-1, m-2 (3 mos)
  #       etc.
  hist.cpr[,sched.ebal01:=ebal+uprin01]
  hist.cpr[,sched.ebal03:=ebal+uprin03]
  hist.cpr[,sched.ebal06:=ebal+uprin06]
  hist.cpr[,sched.ebal12:=ebal+uprin12]
  # SMM single monthly mortality
  # SMM is defined as unscheduled principal divided by scheduled balance ([SF1999] p. SF-5).
  # when calculating 3-,6- & 12-mo SMM, decompound total unsched over period to 1m equivalents 
  # such that, e.g. smm03[m] ~= 1-(1-smm01[m])(1-smm01[m-1])(1-smm01[m-2])
  # we signify ~= (approximate) because a constant 1m SMM for example is applied to balances 
  # which are amortizing as well as prepaying
  hist.cpr[,smm01:=uprin01/sched.ebal01]
  hist.cpr[,smm03:=1-(1-uprin03/sched.ebal03)^(1/3)]
  hist.cpr[,smm06:=1-(1-uprin06/sched.ebal06)^(1/6)]
  hist.cpr[,smm12:=1-(1-uprin12/sched.ebal12)^(1/12)]
  # annualize SMMs to CPRs
  hist.cpr[,cpr01:=1-(1-smm01)^12]
  hist.cpr[,cpr03:=1-(1-smm03)^12]
  hist.cpr[,cpr06:=1-(1-smm06)^12]
  hist.cpr[,cpr12:=1-(1-smm12)^12]
  #
  return(hist.cpr)
}# calc.hist.cpr()
```


```{r plot.hist.cpr_f}
plot.hist.cpr<-function(cf,title=NA,baseline.cpr=NA){
  par(mar=c(bottom=5, left=5, top=3, right=5) + 0.1) # bot, left, top, right in lines
  if(is.na(baseline.cpr)){ baseline.cpr=0.10 }
  maxy<-ceiling(baseline.cpr*10)/5
  ## 0.20 ## scale.axis.max(max(cf$int+cf$sched.prin+cf$unsched.prin))
  hist.cpr<-calc.hist.cpr(cf)
  plot(hist.cpr$mon,hist.cpr$cpr01,col=cpr01.col,type="l",lty=2,xlab="",
       main=title,cex.main=cex.size,
       ylab="",xaxt="n",yaxt="n",ylim=c(0,maxy)) # type="l"
  lines(hist.cpr$cpr03,lty=1,col=cpr03.col) # 
  lines(hist.cpr$cpr06,lty=1,col=cpr06.col) # 
  lines(hist.cpr$cpr12,lty=1,lwd=2,col=cpr12.col) # 
  abline(h=baseline.cpr,lty=2,col=baseline.cpr.col)
  axis(1, at = seq(0, orig.term, 12*5),cex.axis=cex.size)
  axis(2, at = seq(0, maxy, maxy/4),
       sprintf("%3.0f%%",seq(0, maxy, maxy/4)*100),cex.axis=cex.size,las=1)
  par(new=TRUE)     # new plot on same canvas, for ending balance
  plot(hist.cpr$mon,hist.cpr$ebal,type="l",col=ebal.col,lty=2,
       xlab="", xaxt="n",ylab="",yaxt="n",axes=FALSE,
          cex.main=cex.size 
  )
  maxy2<-max(cf[!is.na(cf$bbal)]$bbal)
    displ.y2<-maxy2
  suff.y2<-"($)"
  if(maxy2>1000*1000){
    displ.y2<-maxy2/1000
    suff.y2<-"($1,000s)"
  }

  axis(4, at = seq(0, maxy2, maxy2/4),
     prettyNum(seq(0, displ.y2, displ.y2/4),big.mark=",", scientific=FALSE),
     las=1,cex.axis=cex.size)
  mtext("Age (Mo.)",side=1,line=2.0,cex=cex.size) 
  mtext(paste("Prepayment (CPR)"),side=2,line=4.0,cex=cex.size) 
  mtext(paste("Ending Bal.",suff.y2),side=4,line=4.0,cex=cex.size) 
  legend(x="bottom", xpd=TRUE,inset = c(0, -0.75),horiz=TRUE,cex=cex.size*0.9,
         legend=c("1m CPR (LHS)","3m CPR (LHS)", "6m CPR (LHS)", "12m CPR (LHS)",
                  "End.Bal.(RHS)"),
         lty=c(1,1,1,1,2),
         lwd=c(1,1,1,2,1),
         col=c(cpr01.col,cpr03.col,cpr06.col,cpr12.col,ebal.col),
         bty="n"
         )
} # plot.hist.cpr()
```

# Deriving Observed (Historical) Prepayments from Loan and Pool Cashflows

Given the loan and pool monthly balances and unscheduled principal payments, 
we reverse the process to
infer prepayments as SMM values, annualized as CPRs.

## Monthly Prepayments

As defined earlier:

$$
\begin{aligned}
SMM_i &= \frac{p_{U,i}}{B_{S,i}}\\
\end{aligned}
$$

In deriving prepayment, we would typically be provided actual rather than scheduled balances, so we rewrite as:

$$
\begin{aligned}
SMM_i &= \frac{p_{U,i}}{B_{A,i}+p_{U,i}}\\
\end{aligned}
$$

The variables for SMM~i~ and CPR~i~ used to this point have captured prepayments 
in a single month; i.e., 
they capture 1 month of prepayments from month *i-1* to *i*. As we'll see, the 1 month prepayment 
tends to be volatile when inferring from historical or simulated loan data.

## Term or Average Prepayments

The greater stability of a longer prepayment term better accommodates the comparison of prepayments between different cohorts, or a cohort and a model. 
A Term Prepayment, or Average Prepayment (*SF1999* p.SF-11)
measures prepayment occurring over longer time periods, commonly 3-, 6- and 12 months.
^[Terms longer than 12 months are sometimes reported, such as Since-Issue CPR representing the constant CPR which applied to the pool from origination to today would calculate a balance equaling today's balance.]

For example, a 3m SMM at time *i* 
would capture unscheduled principal from month *i-3* to month *i*
or *p~U,i-2~* + *p~U,i-1~* + *p~U,i~*.
The 3 month scheduled balance
^[*scheduled balance* gains an additional backward-looking dimension.
Today's pool scheduled balance (1 month)
reflects amortization from last month's actual balance, but today's 3 month scheduled 
balance reflects amortization from the actual balance 3 months ago.]
at month *i* 
would be *B~A,i* + *p~U,i-2~* + *p~U,i-1~* + *p~U,i~*.
The 3 month SMM is specified:

$$
\begin{aligned}
SMM_{3,i} &= \sqrt[3]{\frac{\sum_{k=i-2}^{i}p_{U,k}}{B_{A,i}+\sum_{k=i-2}^{i}p_{U,k}}}\\
\end{aligned}
$$
The 12-month SMM has the virtue of being free from 
seasonal variation. The n=month SMM is:

$$
\begin{aligned}
SMM_{n,i} &= \sqrt[n]{\frac{\sum_{k=i+1-n}^{i}p_{U,k}}{B_{A,i}+\sum_{k=i+1-n}^{i}p_{U,k}}}\\
\end{aligned}
$$


The term SMM measures 
are geometric averages expressed as 1-month equivalents, and can be converted to corresponding term CPR in the usual way.

$$
\begin{aligned}
CPR_{n,i} &= 1-(1-SMM_{n,i})^{12} \\
\end{aligned}
$$


## Limitations of Term Prepayments


At loan maturity, both scheduled and actual balances are zero.

$$
\begin{aligned}
B_{A,T} = B_{S,T} = 0
\end{aligned}
$$

This would also be expected at pool stated maturity.
^[Stated maturity is the latest maturity of all loans in the original pool, 
given no early payments.]
Loan curtailments could accelerate paydown prior to the contractual or stated maturity.
*T* represents the earlier (lower) of original term and month of paydown. 
Any historical prepayment ending at month *T* would be the ratio of unscheduled principal
to (zero) scheduled balance, an undefined quantity.

$$
\begin{aligned}
SMM_{n,i} = 
\begin{cases}
\sqrt[n]{\frac{\sum_{k=i+1-n}^{i}p_{U,k}}{B_{A,i}+\sum_{k=i+1-n}^{i}p_{U,k}}} &, n+i<T\\
undefined &,n+i\ge T
\end{cases}
\end{aligned}
$$

## Single Loan Prepayments

The observed CPR for a loan shows either payment-in-full (100 CPR) or monthly curtailment.

```{r loan.hist}
#| fig.cap='Loan Prepayment (Curtailment)'
#| 
title<-sprintf("Single %3.3f%% Loan Cashflow %3.1f%% CPR Curtailments",
               note.rate*100,scalar.cpr*100)
plot.hist.cpr(cfloan,title,baseline.cpr=scalar.cpr)
```

## MBS Convention Pool Prepayments

The observed CPR for an MBS convention pool will return the prepayment vector used 
to pay down the pool.

```{r pool.hist}
#| fig.cap='MBS Convention Pool Prepayment'

title<-sprintf("MBS Convention %3.3f%% Pool Cashflows, %3.1f%% CPR",
               note.rate*100,scalar.cpr*100)
plot.hist.cpr(cfpool,title,baseline.cpr=scalar.cpr)
```

## Loan Simulation Pool Prepayments

Backing out prepayments from simulation is the object of this exercise, as 
it replicates the mechanics of measuring  
historical prepayments.
Here the observed CPR will reflect the paydowns of individual loans in the pool, 
and will evince the largely discrete characteristic of prepayments. 
We can visually discern the stability of the 12-month CPR versus
the shorter term prepayment measures. 
will be quantified in a later section.


```{r sim.cpr}
#| fig.cap='Loan Simulation Pool Prepayment'

title<-sprintf("%3.3f%% Pool Loan Simulation Cashflows, %d Loans, %3.1f%% CPR",
               note.rate*100,loan.count,scalar.cpr*100)
plot.hist.cpr(cfsim,title,baseline.cpr=scalar.cpr)
```


### Loan Count and Pool Paydown


Contrast small and large loan count pools paydowns through simulation.


```{r small.pool.simulation}
set.seed(666) # replicable in isolation
time<-system.time(
  small.cfsim<-simulate.loan.pool.f(orig.term,note.rate,orig.bal,scalar.cpr,small.loan.count)
  )
title<-sprintf("%d Loan Pool Simulation",small.loan.count)
print.time.stats(time,title=title)
```


```{r big.pool.simulation}
set.seed(666) # replicable in isolation
time<-system.time(
  big.cfsim<-simulate.loan.pool.f(orig.term,note.rate,orig.bal,scalar.cpr,big.loan.count)
  )
title<-sprintf("%d Loan Pool Simulation",big.loan.count)
print.time.stats(time,title=title)
```


```{r yuge.pool.simulation}
set.seed(666) # replicable in isolation
time<-system.time(
  yuge.cfsim<-simulate.loan.pool.f(orig.term,note.rate,orig.bal,scalar.cpr,yuge.loan.count)
  )
title<-sprintf("%d Loan Pool Simulation",yuge.loan.count)
print.time.stats(time,title=title)
```


### Pool Loan Count and Paydowns


Examples of small, medium and large pool paydowns are shown below, all modeling
prepayments at a 
`r scalar.cpr.str` CPR.


```{r alt.pool.simulation.results}
#| fig.cap=c('Small Pool Simulation','Medium Pool Simulation','Large Pool Simulation', 'Very Large Pool Simulation')

title<-sprintf("%3.3f%% Pool Loan Simulation Cashflows, %d Loans, %3.1f%% CPR",
                note.rate*100,small.loan.count,scalar.cpr*100)
plot.cfs(small.cfsim,title)


title<-sprintf("%3.3f%% Pool Loan Simulation Cashflows, %d Loans, %3.1f%% CPR",
                note.rate*100,loan.count,scalar.cpr*100)
plot.cfs(cfsim,title)


title<-sprintf("%3.3f%% Pool Loan Simulation Cashflows, %d Loans, %3.1f%% CPR",
                note.rate*100,big.loan.count,scalar.cpr*100)
plot.cfs(big.cfsim,title)


title<-sprintf("%3.3f%% Pool Loan Simulation Cashflows, %d Loans, %3.1f%% CPR",
                note.rate*100,yuge.loan.count,scalar.cpr*100)
plot.cfs(yuge.cfsim,title)
```


CPR derived from the small, medium and large simulations:


```{r alt.sim.cpr}
#| fig.cap=c('Small Pool Historical CPR','Medium Pool Historical CPR','Large Pool Historical CPR','Very Large Pool Historical CPR')

title<-sprintf("%3.3f%% Pool Loan Simulation Cashflows, %d Loans, %3.1f%% CPR",
               note.rate*100,small.loan.count,scalar.cpr*100)
plot.hist.cpr(small.cfsim,title,baseline.cpr=scalar.cpr)

cat('\n\n')
title<-sprintf("%3.3f%% Pool Loan Simulation Cashflows, %d Loans, %3.1f%% CPR",
               note.rate*100,loan.count,scalar.cpr*100)
plot.hist.cpr(cfsim,title,baseline.cpr=scalar.cpr)

cat('\n\n')
title<-sprintf("%3.3f%% Pool Loan Simulation Cashflows, %d Loans, %3.1f%% CPR",
               note.rate*100,big.loan.count,scalar.cpr*100)
plot.hist.cpr(big.cfsim,title,baseline.cpr=scalar.cpr)

cat('\n\n')
title<-sprintf("%3.3f%% Pool Loan Simulation Cashflows, %d Loans, %3.1f%% CPR",
               note.rate*100,yuge.loan.count,scalar.cpr*100)
plot.hist.cpr(yuge.cfsim,title,baseline.cpr=scalar.cpr)
```


# Simulation of Loan Pool Prepayments

Example in the prior section showed single simulation of a pool of mortgage loans.

The simulations in this section
execute 250 or more random trials of pool simulation in the manner of the last example. 
We extract historical prepayments from the simulations and observe the distribution of 
1-, 3-, 6-, and 12-month CPR. For each prepayment term, the
data are non-overlapping, i.e., the 12-month CPR values are spaced 12 months apart.

As is visible in the simulation CPR graphs shown under 
example C above, 
the variation of CPRs grows dramatically 
as the pool seasons and loan count drops. For this reason, we limit the CPRs in
this analysis for the first *n* months, with the assumption that after 5-10 years, 
loans would be pooled together into a large seasoned cohort for the purpose of prepayment analysis.

We describe simulated data:

* Histogram
* Quantile-Quantile Plots
* Statistical Tests for Normality

In the statistical tests the null hypothesis H0 is that the data is normal. A p-value less than the significance threshold (0.01, 0.05) indicates 
evidence that H0 (normality) is not true.


```{r sim.trials_f}
# sim.trials(min.cutoff,max.cutoff,loan.count) ===========================================
#
# run the pool simulation, extract historical CPR, return in list, suitable to be saved 
# in data.table
sim.trials<-function(min.cutoff=1,max.cutoff,loan.count){
  cfsim<-simulate.loan.pool.f(orig.term,note.rate,orig.bal,scalar.cpr,loan.count)
  hist.cpr<-calc.hist.cpr(cfsim)
  months<-nrow(hist.cpr)
  return(list(
        list(hist.cpr[seq(pmax(min.cutoff,1),pmin(max.cutoff,months),by=1),cpr01]),
        list(hist.cpr[seq(pmax(min.cutoff,3),pmin(max.cutoff,months),by=3),cpr03]),
        list(hist.cpr[seq(pmax(min.cutoff,6),pmin(max.cutoff,months),by=6),cpr06]),
        list(hist.cpr[seq(pmax(min.cutoff,12),pmin(max.cutoff,months),by=12),cpr12]))
  )
}# sim.trials()
```

```{r plot.cpr.dist_f}
plot.cpr.dist<-function(cprs,title=NA,desc=NA,lo=NA,hi=NA){
  binwidth=0.0025
  show.max.cpr<-scalar.cpr*4
  breaks<-seq(from=0.0,to=pmax(show.max.cpr,max(cprs,na.rm=TRUE)+binwidth),by=binwidth)
  show.breaks<-seq(from=0.0,to=show.max.cpr,by=0.03)
  h<-hist(cprs,breaks=breaks,plot=FALSE)
  h$counts<-h$counts/sum(h$counts)
  ymax<-ceiling(max(h$counts)*10)/10
  
  nudgex=show.max.cpr*1/100  # 1% of x axis
  nudgey=ymax*1/100

  plot(h,xlim=c(0,show.max.cpr),xaxt="n",xlab="",yaxt="n",ylim=c(0,ymax),
       main=title,cex.main=cex.size,cex.lab=cex.size)
  abline(v=scalar.cpr,lty=3,lwd=1,col=baseline.cpr.col)
  if(!is.na(lo)){
    abline(v=lo,lty=3,lwd=1,col=baseline.cpr.col)
    text(x=lo+nudgex,y=(1-nudgey)*ymax,"2.5 %ile",cex=cex.size*0.9,srt=90,
         adj=c(1,1),col=baseline.cpr.col)
  }
  if(!is.na(hi)){
    abline(v=hi,lty=3,lwd=1,col=baseline.cpr.col)
    text(x=hi+nudgex,y=(1-nudgey)*ymax,"97.5 %ile",cex=cex.size*0.9,srt=90,
         adj=c(1,1),col=baseline.cpr.col)
  }

  axis(1, at = show.breaks,cex.axis=cex.size,
              sprintf("%3.0f%%",show.breaks*100),cex.axis=cex.size,las=1)
  axis(2, at = seq(0,ymax,length.out=5),cex.axis=cex.size,
              sprintf("%3.1f%%",seq(0,ymax,length.out=5)*100),cex.axis=cex.size,las=1)
  mtext(desc,side=1,line=3.0,cex=cex.size) 
  cat('\n\n')
}# plot.cpr.dist()
```

```{r run.pool.simulation_f}
pool.simulation<-function(trials,min.cutoff=1,max.cutoff,loan.count){
  results<-data.table(trial=1:trials)
  time<-system.time(
    results[,c("cpr01","cpr03","cpr06","cpr12"):=
              sim.trials(min.cutoff,max.cutoff,loan.count),by="trial"]
  )
  
  # organize all CPR output for all trials
  cpr01<-do.call(c,results$cpr01)
  cpr03<-do.call(c,results$cpr03)
  cpr06<-do.call(c,results$cpr06)
  cpr12<-do.call(c,results$cpr12)
  # gather distribution statistics
  quants=c(0.005,0.025,0.05,0.50,0.95,0.975,0.995)
  return(list(
    trials=trials,
    loan.count=loan.count,
    min.cutoff=min.cutoff,
    max.cutoff=max.cutoff,
    cpr01=cpr01[!is.na(cpr01)],
    cpr03=cpr03[!is.na(cpr03)],
    cpr06=cpr06[!is.na(cpr06)],
    cpr12=cpr12[!is.na(cpr12)],
    cpr01.q=quantile(cpr01  ,quants,na.rm=TRUE),
    cpr03.q=quantile(cpr03  ,quants,na.rm=TRUE),
    cpr06.q=quantile(cpr06  ,quants,na.rm=TRUE),
    cpr12.q=quantile(cpr12  ,quants,na.rm=TRUE),
    time=time
  ))
}# pool.simulation()
```

```{r show.pool.sim.results_f}
show.pool.sim.results<-function(sim){
  trials<-sim$trials
  loan.count<-sim$loan.count
  min.cutoff<-sim$min.cutoff
  max.cutoff<-sim$max.cutoff
  time<-sim$time
  cpr01<-sim$cpr01
  cpr03<-sim$cpr03
  cpr06<-sim$cpr06
  cpr12<-sim$cpr12
  cpr01.q<-sim$cpr01.q
  cpr03.q<-sim$cpr03.q
  cpr06.q<-sim$cpr06.q
  cpr12.q<-sim$cpr12.q
  
  #title<-sprintf("%d Loan Pool Simulation, %d Trials",loan.count,trials)
  #print(print.time.stats(time=time,title=title))

  title<-sprintf("Loan Simulation @ %3.1f%% CPR\n%d loans/pool, %d trials, Months %d-%d",
                 scalar.cpr*100,loan.count,trials,min.cutoff,max.cutoff)
  par(mfrow=c(1,2))
  plot.cpr.dist(cpr01,title=title,desc="1m Historical CPR",
                lo=cpr01.q["2.5%"],hi=cpr01.q["97.5%"])
  plot.cpr.dist(cpr03,title=title,desc="3m Historical CPR",
                lo=cpr03.q["2.5%"],hi=cpr03.q["97.5%"])
  par(mfrow=c(1,2))
  plot.cpr.dist(cpr06,title=title,desc="6m Historical CPR",
                lo=cpr06.q["2.5%"],hi=cpr06.q["97.5%"])
  plot.cpr.dist(cpr12,title=title,desc="12m Historical CPR",
                lo=cpr12.q["2.5%"],hi=cpr12.q["97.5%"])
}# show.pool.sim.results()
```

```{r show.norm.stat_f}
norm.test<-function(dat,title){
  if(length(dat)>5000){
    dat<-sample(dat,5000,replace=FALSE)
  }
  print(sprintf("%s: length=%d",title,length(dat)))
  shapiro<-shapiro.test(dat)
  ks<-ks.test(dat,"pnorm")
  ad<-ad.test(dat)
  tab<-data.frame(
    method=c(shapiro$method,ad$method,)
  )
}

show.norm.stat<-function(sim,title){
  par(mfrow=c(1,4))
  qqnorm(sim$cpr01,main=sprintf(title,"1m CPR",sim$loan.count),cex.main=cex.size)
  qqline(sim$cpr01,col = "red",lwd=2,lty=2)
  cat('\n\n')
  qqnorm(sim$cpr03,main=sprintf(title,"3m CPR",sim$loan.count),cex.main=cex.size)
  qqline(sim$cpr03,col = "red",lwd=2,lty=2)
  cat('\n\n')
  #par(mfrow=c(1,2))
  qqnorm(sim$cpr06,main=sprintf(title,"6m CPR",sim$loan.count),cex.main=cex.size)
  qqline(sim$cpr06,col = "red",lwd=2,lty=2)
  cat('\n\n')
  qqnorm(sim$cpr12,main=sprintf(title,"12m CPR",sim$loan.count),cex.main=cex.size)
  qqline(sim$cpr12,col = "red",lwd=2,lty=2)
  cat('\n\n')
  
   dat<-sim$cpr01
  if(length(dat)>5000){ # Shapiro-Wilks does not run if n>5000
    dat<-sample(dat,5000,replace=FALSE)
  }
  shapiro01<-shapiro.test(dat)
  ks01<-ks.test(dat,"pnorm",mean=mean(dat),sd=sd(dat))
  ad01<-ad.test(dat)
  
  dat<-sim$cpr03
    if(length(dat)>5000){
    dat<-sample(dat,5000,replace=FALSE)
  }
  shapiro03<-shapiro.test(dat)
  ks03<-ks.test(dat,"pnorm",mean=mean(dat),sd=sd(dat))
  ad03<-ad.test(dat)
  
  dat<-sim$cpr06
    if(length(dat)>5000){
    dat<-sample(dat,5000,replace=FALSE)
  }
  shapiro06<-shapiro.test(dat)
  ks06<-ks.test(dat,"pnorm",mean=mean(dat),sd=sd(dat))
  ad06<-ad.test(dat)
  
  dat<-sim$cpr12
    if(length(dat)>5000){
    dat<-sample(dat,5000,replace=FALSE)
  }

  shapiro12<-shapiro.test(dat)
  ks12<-ks.test(dat,"pnorm",mean=mean(dat),sd=sd(dat))
  ad12<-ad.test(dat)

  tab<-data.frame(
    cpr01.stats=c(shapiro01$statistic,shapiro01$p.value,
                 ks01$statistic,ks01$p.value,
                 ad01$statistic,ad01$p.value),
    cpr03.stats=c(shapiro03$statistic,shapiro03$p.value,
                 ks03$statistic,ks03$p.value,
                 ad03$statistic,ad03$p.value),
    cpr06.stats=c(shapiro06$statistic,shapiro06$p.value,
                 ks06$statistic,ks06$p.value,
                 ad06$statistic,ad06$p.value),
    cpr12.stats=c(shapiro12$statistic,shapiro12$p.value,
                 ks12$statistic,ks12$p.value,
                 ad12$statistic,ad12$p.value)

 )

  tab<-t(tab)
  row.names(tab)=c("1m CPR","3m CPR","6m CPR","12m CPR")
  colnames(tab)<-c("sw.stat","sw.pvalue","ks.stat","ks.pvalue","ad.stat","ad.pvalue")
  data.frame(tab) %>%
    mutate(sw.pvalue = cell_spec(format.pval(sw.pvalue,3), color = ifelse(sw.pvalue > 0.05, "red","black"))) %>%
    mutate(ks.pvalue = cell_spec(format.pval(ks.pvalue,3), color = ifelse(ks.pvalue > 0.05, "red","black"))) %>%
    mutate(ad.pvalue = cell_spec(format.pval(ad.pvalue,3), color = ifelse(ad.pvalue > 0.05, "red","black"))) %>%
  kbl(escape=FALSE,booktabs = T, longtable=T,
               caption=sprintf(
                 paste("%d Loans/Pool",
                       "Shapiro-Wilks (S-W),",
                       "Kolmogorov-Smirnov (K-S),",
                       "Anderson-Darling (A-D)",
                       "tests"),
                                sim$loan.count),
        col.name=c("S-W (W)","S-W p-value",
                   "K-S (D)","K-S p-value",
                   "A-D (A)","A-D p-value"
                   ),
        digits=4
        ) %>% kable_paper("striped", full_width = F) # kable_styling()

}# show.norm.stat()
```

```{r small.pool.simulation.trials,results='asis',fig.keep='high'}
#| fig.cap=c('Small Pool 1m, 3m CPR','Small Pool 6m, 12m CPR','Small Pool CPR Q-Q')

min.cutoff<-1
max.cutoff<-60 # only include prepay from month 1:max.cutoff
trials<-250
#
lc<-100
cat(sprintf("\n\n## Small Pool Statistics (%d Loans/Pool)\n",lc))
set.seed(666) # for unit replicability
sim<-pool.simulation(trials,min.cutoff,max.cutoff,loan.count=lc)
title<-sprintf("%d Loan Pool Simulation, %d Trials",sim$loan.count,sim$trials)
print.time.stats(time=sim$time,title=title)
show.pool.sim.results(sim=sim)
show.norm.stat(sim,"%s norm-QQ (%d loans)")
```

```{r results='asis',eval=!params$run_heavy_simulation}
cat(sprintf("\n\n## SKIPPING LARGE SIMULATIONS\n",lc))
```

```{r med.pool.simulation.trials,results='asis',eval=params$run_heavy_simulation}
#| fig.cap=c('Medium Pool 1m, 3m CPR','Medium Pool 6m, 12m CPR','Medium Pool CPR Q-Q')

lc<-250
cat(sprintf("\n\n## Medium Pool Statistics (%d Loans/Pool)\n",lc))
set.seed(666) # for unit replicability
sim<-pool.simulation(trials,min.cutoff,max.cutoff,loan.count=lc)
title<-sprintf("%d Loan Pool Simulation, %d Trials",sim$loan.count,sim$trials)
print.time.stats(time=sim$time,title=title)
show.pool.sim.results(sim=sim)
show.norm.stat(sim,"%s norm-QQ (%d loans)")
```

```{r medbig.pool.simulation.trials,results='asis',eval=params$run_heavy_simulation}
#| fig.cap=c('Medium/Large Pool 1m, 3m CPR','Medium/Large Pool 6m, 12m CPR','Medium/Large Pool CPR Q-Q')

lc<-500
cat(sprintf("\n\n## Medium-Large Pool Statistics (%d Loans/Pool)\n",lc))
set.seed(666) # for unit replicability
sim<-pool.simulation(trials,min.cutoff,max.cutoff,loan.count=lc)
title<-sprintf("%d Loan Pool Simulation, %d Trials",sim$loan.count,sim$trials)
print.time.stats(time=sim$time,title=title)
show.pool.sim.results(sim=sim)
show.norm.stat(sim,"%s norm-QQ (%d loans)")
```


```{r big.pool.simulation.trials,results='asis',eval=params$run_heavy_simulation}
#| fig.cap=c('Large Pool 1m, 3m CPR','Large Pool 6m, 12m CPR','Large Pool CPR Q-Q')

lc<-1000
cat(sprintf("\n\n## Large Pool Statistics (%d Loans/Pool)\n",lc))
set.seed(666) # for unit replicability
sim<-pool.simulation(trials,min.cutoff,max.cutoff,loan.count=lc)
title<-sprintf("%d Loan Pool Simulation, %d Trials",sim$loan.count,sim$trials)
print.time.stats(time=sim$time,title=title)
show.pool.sim.results(sim=sim)
show.norm.stat(sim,"%s norm-QQ (%d loans)")
```

# Appendix: Mortgage Formulae

Scope: Fixed-Rate Level-Pay mortgages

  * Fixed-Rate: constant interest rate over the life of the loan
  
  * Level-Pay: Loan is structured such that monthly payment is constant over the life of the loan.

The level-pay structure is facilitated by *amortizing* the balance over the life of the loan after paying monthly interest. The amount of the amortization is known as the *scheduled principal* and the remaining balance is known as the *scheduled balance*.


Each month the borrower remits the scheduled monthly payment *m*, comprising of interest *i~i~* and principal *p~i~*, the reduction of principal resulting in a monthly
ending balance *B~i~*.

$$
\begin{aligned}
m & = i_i + p_i \\
i_i & =B_{i-1} r_m\\
p_i & =m-B_{i-1} r_m\\
B_i & =B_{i-1}-p_1\\
   & =B_{i-1}-(m-B_0 r_m)\\
   & =B_{i-1}+B_{i-1} r_m-m\\
   & =B_{i-1}(1+r_m)-m
\end{aligned}
$$

Determining principal, interest and balance at the end of Month 1.
*B~0~* is the original balance, *m* is the monthly borrower payment,
*r~m~* is the monthly interest rate, *i~1~* is interest amount in month 1,
*p~1~* is the principal in month 1 and *B~1~* is the balance at the end of month 1.

$$
\begin{aligned}
i_1 & =B_0 r_m\\
p_1 & =m-B_0 r_m\\
B_1 & =B_0-p_1\\
   & =B_0-(m-B_0 r_m)\\
   & =B_0+B_0 r_m-m\\
   & =B_0(1+r_m)-m
\end{aligned}
$$

Determining principal, interest and balance at the end of Month 2 


$$
\begin{aligned}
i_2 & =B_1 r_m\\
 & =(B_0(1+r_m)-m)r_m\\
 & =B_0 r_m (1+r_m)-m r_m\\
p_2 & =m-i_2\\
  & =m-(B_0 r_m (1+r_m)-m r_m)\\
  & =m-B_0 r_m (1+r_m)+m r_m\\
B_2 & =B_0-p_1-p_2\\
  & =B_0-(m-B_0 r_m)-(m-B_0 r_m (1+r_m)+m r_m)\\
  & =B_0-m+B_0 r_m-m+B_0 r_m (1+r_m)-m r_m\\
  & =B_0-m+B_0 r_m-m + B_0 r_m + B_0 r_m^2-m r_m\\
  & = B_0 r_m^2 + 2 B_0 r_m + B_0-m-m -m r_m\\
  & = B_0 (r_m^2 + 2 r_m + 1) - m (1+r_m) - m\\
  & = B_0 (1+r_m)^2 - m (1+r_m) - m\\
\end{aligned}
$$
Determining principal, interest and balance at the end of Month 3 

$$
\begin{aligned}
i_3 & =B_2 r_m\\
 & =(B_0 (1+r_m)^2 - m (1+r_m) - m)r_m\\
p_3 & =m-i_3\\
  & =m-((B_0 (1+r_m)^2 - m (1+r_m) - m)r_m)\\
B_3 & =B_0-p_1-p_2-p_3\\
  & =B_0-(m-B_0 r_m)-(m-B_0 r_m (1+r_m)+m r_m)-(m-((B_0 (1+r_m)^2 - m (1+r_m) - m)r_m))\\
  & =B_0-m+B_0 r_m-m+B_0 r_m (1+r_m)-m r_m-m+((B_0 (1+r_m)^2 - m (1+r_m) - m)r_m))\\
  & =B_0-m+B_0 r_m-m+B_0 r_m (1+r_m)-m r_m-m+B_0 r_m (1+r_m)^2 - r_m m (1+r_m) - r_m m\\
  & =B_0
  +B_0 r_m
  +B_0 r_m (1+r_m)
  +B_0 r_m (1+r_m)^2 
  -m
  -m
  -m r_m
  -m
  - r_m m (1+r_m) 
  - r_m m\\
    & =B_0
  +B_0 r_m
  +B_0 r_m (1+r_m)
  +B_0 r_m (r_m^2+2 r_m + 1) 
  -m
  -m
  -m r_m
  -m
  - r_m m (1+r_m) 
  - r_m m\\
      & =B_0
  +B_0 r_m
  +B_0 (r_m^2+r_m)
  +B_0  (r_m^3+2 r_m^2 + r_m) 
  -m
  -m
  -m r_m
  -m
  - m (r_m^2+r_m) 
  - r_m m\\
      & =B_0 (
  1
  +r_m
  +(r_m^2+r_m)
  +(r_m^3+2 r_m^2 + r_m) 
  )
  -m
  -m
  -m r_m
  -m
  - m r_m^2-m r_m 
  - r_m m\\
  & =B_0 (
  r_m^3
   +3 r_m^2 
 +3 r_m
    +1
  )
  -m
  -m
  -m r_m
  -m
  - m r_m^2-m r_m 
  - r_m m\\
  & =B_0 (
  r_m^3
   +3 r_m^2 
 +3 r_m
    +1
  )
  - m r_m^2
  -m r_m
  -m r_m 
  -m
  -m
  - r_m m
    -m\\
  & =B_0 (
  r_m^3
   +3 r_m^2 
 +3 r_m
    +1
  )
  - m (r_m^2
  + 2 r_m
  +1)
  -m (
   r_m + 1
  )
    -m\\
  & =B_0 (1+ r_m)^3
  - m (1+r_m)^2
  -m (
   1+r_m 
  )
    -m\\
\end{aligned}
$$

Generalizing from the above a 30 year loan would we have:

$$
\begin{aligned}
 B_{360} & =B_0 (1+ r_m)^{360}
  - m (1+r_m)^{359}
  - m (1+r_m)^{358}
  ...
    -m\\
 & =B_0 (1+ r_m)^{360}
  - \left[ \ 
  m (1+r_m)^{359}
  + m (1+r_m)^{358}
  ...
  +m \ \right]
\end{aligned}
$$
To derive *m*,  observe that *m* coefficient terms
represent a geometric series, which is nominally specified:


$$
\begin{aligned}
S_n = a r^0 + a r^1 + ... +a r^n = \sum_{k=0}^n a r^k
\end{aligned}
$$
The closed form solution for a geometric series is:

$$
\begin{aligned}
S_n = 
\begin{cases}
a (n+1) & r=1 \\
a \left(\frac{1-r^{n+1}}{1-r}\right) & r\ne1
\end{cases}
\end{aligned}
$$
Substituting loan variables:

$$
\begin{aligned}
r_m & \ne 0\\
S_n &= m \left(\frac{1-(1+r_m)^{n+1}}{1-(1+r_m)}\right)
\end{aligned}
$$
Replacing the 2nd to nth terms in the partial sum:

$$
\begin{aligned}
r_m & \ne 0\\
B_{360} & =B_0 (1+ r_m)^{360} -  S_{359}\\
B_{360} & =B_0 (1+ r_m)^{360} -  m \left(\frac{1-(1+r_m)^{360}}{1-(1+r_m)}\right)\\
\end{aligned}
$$

The final balance B~360~ is zero, allowing us to isolate *m*:

$$
\begin{aligned}
0 & =B_0 (1+ r_m)^{360} -  m \left(\frac{1-(1+r_m)^{360}}{1-(1+r_m)}\right)\\
m \left(\frac{1-(1+r_m)^{360}}{1-(1+r_m)}\right) & =B_0 (1+ r_m)^{360} \\
m & =B_0 (1+ r_m)^{360} \left(\frac{1-(1+r_m)}{1-(1+r_m)^{360}}\right) \\
 & =B_0 (1+ r_m)^{360} \left(\frac{r_m}{(1+r_m)^{360}-1}\right) \\
 & =B_0 r_m \frac {(1+ r_m)^{360}}{(1+r_m)^{360}-1} \\
 & =B_0 \frac{r_m}{1-(1+r_m)^{-360}} 
\end{aligned}
$$

For the corner case  r~m~ = 0, we substitute

$$
\begin{aligned}
r_m &= 0 \\
0 & =B_0 (1+ r_m)^{360} -  S_{359}\\
0 & =B_0 -  m 360\\
m &=\frac{B_0}{360}
\end{aligned}
$$


# Appendix: Listing of R Code used in this Document

## Amortization Functions

### A. Single Loan Amortization 

```{r level.pay.calc_f,eval=FALSE,echo=TRUE}
```

```{r amort.loan.cf_f,eval=FALSE,echo=TRUE}
```

### B. MBS Convention Pool Amortization 

```{r amort.pool.cf_f,eval=FALSE,echo=TRUE}
```

### C. Loan Simulation Pool Amortization 

```{r simulate.loan.pool_f,eval=FALSE,echo=TRUE}
```

```{r simulate.loan.pool.f_f,eval=FALSE,echo=TRUE}
```

## Observed (historical) CPR Computation

```{r calc.hist.cpr.f,echo=TRUE,eval=FALSE}
```


## Loan Parameters used in this Document

```{r loan.parameters,eval=FALSE,echo=TRUE}
```

```{r pool.simulation.params,eval=FALSE,echo=TRUE}
```

## Basic Loan Amortization Mechanics

### Loan Scheduled Payments

```{r amortization,eval=FALSE,echo=TRUE}
```

### Loan Repayment (Payment in Full)

```{r payment.in.full,eval=FALSE,echo=TRUE}
```

### Loan Curtailment

```{r curtailment,eval=FALSE,echo=TRUE}
```


## Run Cashflows

### A. Loan

```{r amort.loan,eval=FALSE,echo=TRUE}
```

### B. Pool (MBS Convention)

```{r amort.pool,eval=FALSE,echo=TRUE}
```

### C. Pool (Simulation)

```{r sim.trials_f,eval=FALSE,echo=TRUE}
```

```{r pool.simulation,eval=FALSE,echo=TRUE}
```

```{r pool.simulation.results,eval=FALSE,echo=TRUE}
```

```{r sim.cpr,eval=FALSE,echo=TRUE}
```

```{r alt.sim.cpr,eval=FALSE,echo=TRUE}
```

## CPR Statistics

```{r plot.cpr.dist_f,echo=TRUE,eval=FALSE}
```

```{r run.pool.simulation_f,eval=FALSE,echo=TRUE}
```

```{r show.pool.sim.results_f,eval=FALSE,echo=TRUE}
```

```{r show.norm.stat_f,eval=FALSE,echo=TRUE}
```


```{r small.pool.simulation.trials,results='asis',eval=FALSE,echo=TRUE}
```

```{r med.pool.simulation.trials,results='asis',eval=FALSE,echo=TRUE}
```

```{r medbig.pool.simulation.trials,results='asis',eval=FALSE,echo=TRUE}
```

```{r big.pool.simulation.trials,results='asis',eval=FALSE,echo=TRUE}
```

## Plot/Print Utility Functions

```{r plot.cfs.f,eval=FALSE,echo=TRUE}
```

```{r plot.comp.bals.f,eval=FALSE,echo=TRUE}
```

```{r plot.hist.cpr_f,eval=FALSE,echo=TRUE}
```

```{r print.time.stats_f,eval=FALSE,echo=TRUE}
```

# Colophon

```{r colophon,echo=TRUE,comment=''}
print(sessionInfo())
packinfo <- installed.packages(fields = c("Package", "Version"))
print(packinfo[,  "Version", drop=F])
```